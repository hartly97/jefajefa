1) Fix app/javascript/controllers/index.js

Replace the whole file with this single, clean version (pick ONE style; I’m giving the common “application” style):

// app/javascript/controllers/index.js
import { Application } from "@hotwired/stimulus"
import CitationsController from "./citations_controller"

const application = Application.start()
application.register("citations", CitationsController)

// Optional: export if you need to access Application elsewhere
export { application }


(Your file currently starts Application twice and imports the same controller twice — remove the duplicates.)

2) Make sure your entrypoint imports the controllers

In Rails 7 with jsbundling (esbuild), your main entrypoint is usually app/javascript/application.js. It must import the controllers folder:

// app/javascript/application.js
import "@hotwired/turbo-rails"
import "./controllers"   // <-- this line ensures index.js runs


Then in your layout you should be including this pack:

<%= javascript_include_tag "application", defer: true %>


(If you’re on importmap instead of jsbundling, you’d use javascript_importmap_tags and pin_all_from, but you said you’re using esbuild.)

3) Confirm your controller file exists (you posted it — looks good)

app/javascript/controllers/citations_controller.js:

import { Controller } from "@hotwired/stimulus"

// data-controller="citations"
export default class extends Controller {
  static targets = ["list", "template"]
  static values = { index: Number }

  connect() {
    if (this.indexValue == null) this.indexValue = this._nextIndex()
  }

  add(event) {
    event.preventDefault()
    const html = this.templateTarget.innerHTML.replaceAll("NEW_RECORD", this.indexValue)
    this.listTarget.insertAdjacentHTML("beforeend", html)
    this.indexValue++
  }

  remove(event) {
    event.preventDefault()
    const wrapper = event.currentTarget.closest("[data-citations-wrapper]")
    const destroyField = wrapper.querySelector("input[name*='[_destroy]']")
    if (destroyField) {
      destroyField.value = "1"
      wrapper.style.display = "none"
    } else {
      wrapper.remove()
    }
  }

  _nextIndex() {
    const items = this.listTarget.querySelectorAll("[data-citations-wrapper]")
    return items.length
  }
}

4) Wire the HTML targets (so the controller actually finds them)

In your citations fields partial (or wrapper around it), add data-controller and targets. Example pattern:

<div data-controller="citations"
     data-citations-index-value="<%= @record.citations.size %>">

  <div data-citations-target="list">
    <% f.fields_for :citations do |cf| %>
      <div data-citations-wrapper>
        <%= render "citations/fields", f: cf, sources: Source.order(:title) %>
      </div>
    <% end %>
  </div>

  <template data-citations-target="template">
    <div data-citations-wrapper>
      <%= f.fields_for :citations, Citation.new, child_index: "NEW_RECORD" do |cf| %>
        <%= render "citations/fields", f: cf, sources: Source.order(:title) %>
      <% end %>
    </div>
  </template>

  <p>
    <button type="button" data-action="citations#add">Add citation</button>
  </p>
</div>


Inside each rendered citation row, add a remove button:

<button type="button" data-action="citations#remove">Remove</button>


(Your controller will set _destroy and hide the row.)

5) Rebuild & verify

Stop and restart your dev process (bin/dev) so esbuild picks up changes.

Watch the console: you should NOT see “Could not resolve ./citations_controller”.

Open the page, check devtools Console for “CitationsController connected” (you can add that log to connect() if you like).

6) If you ever add more controllers later

Let Stimulus keep things tidy by generating the skeleton:

bin/rails generate stimulus citations
# or if the file exists already:
bin/rails stimulus:manifest:update


This avoids drift in index.js.