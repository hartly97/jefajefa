# class WarsController < ApplicationController
#   before_action :set_war,      only: [:show, :edit, :update, :destroy, :regenerate_slug]
#   before_action :set_sources,  only: [:new, :edit]
#   before_action :ensure_nested_source_builds, only: [:new, :edit]

#   def index
#    @wars = War. order(:name)
#   end

#   def new
#     @war = War.new
#     @war.citations.build
#   end

#   def edit
#     @war.citations.build if @war.citations.empty?
#   end
  

#   def show
#   @war = War.includes(involvements: :participant).find_by!(slug: params[:id])
#   @involvements = @war.involvements
# end

#  def create
#     @war = War.new(war_params)
#     if @war.save
#       redirect_to @war, notice: "War created."
#     else
#       render :new, status: :unprocessable_entity
#     end
#   end

#   # PATCH/PUT /wars/:id
#   def update
#     if @war.update(war_params)
#       redirect_to @war, notice: "War updated."
#     else
#       render :edit, status: :unprocessable_entity
#     end
#   end

#   # DELETE /wars/:id
#   def destroy
#     @war.destroy
#     redirect_to wars_path, notice: "War deleted."
#   end

#   # PATCH /wars/:id/regenerate_slug
#   def regenerate_slug
#     @war.regenerate_slug!
#     redirect_to @war, notice: "Slug regenerated."
#   end
#   def ensure_nested_source_builds
#     (@war || @record)&.citations&.each { |c| c.build_source if c.source.nil? }
#   end
# end

#   private
#   # Needed by the citations partial for the Source dropdown
#   def load_sources
#     @sources = Source.order(:title)
#   end
  
# def set_sources
#   @sources = Source.order(:title)
# end

#   def set_war
#     @war = War.find_by(slug: params[:id]) || War.find(params[:id])
#   end

#   def war_params
#     params.require(:war).permit(
#       :name, :start_year, :end_year, :note,
#       { category_ids: [] },
#       citations_attributes: [
#         :id, :source_id, :pages, :quote, :note, :_destroy,
#         { source_attributes: [:id, :title, :author, :publisher, :year, :url, :details, :repository, :link_url] }
#       ],
#       involvements_attributes: [
#         :id, :involvable_type, :involvable_id, :role, :year, :note, :_destroy
#       ]
#     )
#   end

# app/controllers/wars_controller.rb
class WarsController < ApplicationController
  before_action :set_war,                      only: [:show, :edit, :update, :destroy, :regenerate_slug]
  before_action :set_sources,                  only: [:new, :edit]
  before_action :ensure_nested_source_builds,  only: [:new, :edit]

  def index
    @wars = War.order(:name)
  end

  def new
    @war = War.new
    @war.citations.build
  end

  def edit
    @war.citations.build if @war.citations.empty?
  end

  def show
    # @war is already set (and eager-loaded) by set_war
    @involvements = @war.involvements   # non-nil now
  end

  def create
    @war = War.new(war_params)
    if @war.save
      redirect_to @war, notice: "War created."
    else
      render :new, status: :unprocessable_entity
    end
  end

  def update
    if @war.update(war_params)
      redirect_to @war, notice: "War updated."
    else
      render :edit, status: :unprocessable_entity
    end
  end

  def destroy
    @war.destroy
    redirect_to wars_path, notice: "War deleted."
  end

  def regenerate_slug
    @war.regenerate_slug!
    redirect_to @war, notice: "Slug regenerated."
  end

  private

  # Eager-load participants to avoid N+1s on the show page
  def set_war
    @war = War.includes(involvements: :participant)
              .find_by(slug: params[:id]) || War.find(params[:id])
  end

  # For your citations formâ€™s Source dropdown
  def set_sources
    @sources = Source.order(:title)
  end

  # Ensure each nested citation has a source object to edit
  def ensure_nested_source_builds
    (@war || @record)&.citations&.each { |c| c.build_source if c.source.nil? }
  end

  def war_params
    params.require(:war).permit(
      :name, :start_year, :end_year, :note,
      { category_ids: [] },
      citations_attributes: [
        :id, :source_id, :pages, :quote, :note, :_destroy,
        { source_attributes: [:id, :title, :author, :publisher, :year, :url, :details, :repository, :link_url] }
      ],
      # Only keep nested involvements if you actually render a nested form.
      # Since War is the involvable, we accept participant fields here.
      involvements_attributes: [
        :id,
        :participant_id, :participant_type, # participant_type can be defaulted to "Soldier" in the model/controller
        :role, :year, :note,
        :_destroy
      ]
    )
  end
end
