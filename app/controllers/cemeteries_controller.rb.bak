# class CemeteriesController < ApplicationController
#  before_action :set_cemetery, only: [:show, :edit, :update, :destroy, :regenerate_slug]
  
#   def index
#     @cemetery = Cemetery.order(:name).page(params[:page])
#   end

#   def show
#     # @cemetery = Cemetery.find_by!(slug: params[:id])
#   end

#   def new
#     @cemetery = Cemetery.new
#   end
#   def create
#     @cemetery = Cemetery.new(cemetery_params)
#     if @cemetery.save
     
#       redirect_to @cemetery, notice: "Cemetery created."
#     else
#       render :new, status: :unprocessable_entity
#     end
#   end
#   def edit
#     # @cemetery = Cemetery.find_by!(slug: params[:id])
#   end

#    def update
#     @cemetery = Cemetery.find_by!(slug: params[:id])
#     if @cemetery.update(cemetery_params)
    
#       redirect_to @cemetery, notice: "Cemetery updated."
#     else
#       render :edit, status: :unprocessable_entity
#     end
#   end

#   def destroy
#     @cemetery = Cemetery.find_by!(slug: params[:id])
#     @cemetery.destroy
#     redirect_to cemeteries_path, notice: "Cemetery deleted."
#   end

#   private

# def cemetery_params
#   params.require(:cemetery).permit(
#     :name,
#     { category_ids: [] },
#     citations_attributes: [
#       :id, :_destroy, :source_id,
#       :page, :pages, :folio, :column, :line_number, :record_number, :locator,
#       :image_url, :image_frame, :roll, :enumeration_district, :quote, :note,
#       { source_attributes: [:id, :title, :author, :publisher, :year, :url, :details, :repository, :link_url] }
#     ]
#   )
# end
# end

class CemeteriesController < ApplicationController
  before_action :set_cemetery, only: [:show, :edit, :update, :destroy, :regenerate_slug]
  before_action :set_sources,  only: [:new, :edit]
  before_action :ensure_nested_source_builds, only: [:new, :edit]

  def index
    @cemeteries = maybe_page(Cemetery.order(:name))
  end

  def show
    @involvements = @cemetery.involvements.includes(:participant)
  end

  def new
    @cemetery = Cemetery.new
    @cemetery.citations.build
  end

  def create
    @cemetery = Cemetery.new(cemetery_params)
    if @cemetery.save
      redirect_to @cemetery, notice: "Cemetery created."
    else
      render :new, status: :unprocessable_entity
    end
  end

  def edit
    @cemetery.citations.build if @cemetery.citations.empty?
  end

  def update
    if @cemetery.update(cemetery_params)
      redirect_to @cemetery, notice: "Cemetery updated."
    else
      render :edit, status: :unprocessable_entity
    end
  end

  def destroy
    @cemetery.destroy
    redirect_to cemeteries_path, notice: "Cemetery deleted."
  end

  def regenerate_slug
    @cemetery.regenerate_slug!
    redirect_to @cemetery, notice: "Slug regenerated."
  end

  private

  def set_cemetery
    @cemetery = Cemetery.includes(involvements: :participant)
                        .find_by(slug: params[:id]) || Cemetery.find(params[:id])
  end

  def set_sources
    @sources = Source.order(:title)
  end

  def ensure_nested_source_builds
    (@cemetery || @record)&.citations&.each { |c| c.build_source if c.source.nil? }
  end

  def cemetery_params
    params.require(:cemetery).permit(
      :name, :city, :state, :country, :note,
      { category_ids: [] },
      citations_attributes: [
        :id, :_destroy, :source_id,
        :page, :pages, :folio, :column, :line_number, :record_number, :locator,
        :image_url, :image_frame, :roll, :enumeration_district, :quote, :note,
        { source_attributes: [:id, :title, :author, :publisher, :year, :url, :details, :repository, :link_url] }
      ],
      involvements_attributes: [
        :id, :participant_id, :participant_type, :role, :year, :note, :_destroy
      ]
    )
  end
end
